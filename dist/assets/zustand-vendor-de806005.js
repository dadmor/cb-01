import{r as k,g as z,R as w}from"./react-vendor-4ba9703c.js";var F={exports:{}},H={},M={exports:{}},P={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var p=k;function L(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var V=typeof Object.is=="function"?Object.is:L,C=p.useState,j=p.useEffect,J=p.useLayoutEffect,N=p.useDebugValue;function T(e,t){var r=t(),n=C({inst:{value:r,getSnapshot:t}}),s=n[0].inst,o=n[1];return J(function(){s.value=r,s.getSnapshot=t,O(s)&&o({inst:s})},[e,r,t]),j(function(){return O(s)&&o({inst:s}),e(function(){O(s)&&o({inst:s})})},[e]),N(r),r}function O(e){var t=e.getSnapshot;e=e.value;try{var r=t();return!V(e,r)}catch{return!0}}function U(e,t){return t()}var G=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?U:T;P.useSyncExternalStore=p.useSyncExternalStore!==void 0?p.useSyncExternalStore:G;M.exports=P;var q=M.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b=k,K=q;function Q(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var X=typeof Object.is=="function"?Object.is:Q,Y=K.useSyncExternalStore,Z=b.useRef,A=b.useEffect,B=b.useMemo,ee=b.useDebugValue;H.useSyncExternalStoreWithSelector=function(e,t,r,n,s){var o=Z(null);if(o.current===null){var d={hasValue:!1,value:null};o.current=d}else d=o.current;o=B(function(){function S(i){if(!a){if(a=!0,c=i,i=n(i),s!==void 0&&d.hasValue){var y=d.value;if(s(y,i))return v=y}return v=i}if(y=v,X(c,i))return y;var u=n(i);return s!==void 0&&s(y,u)?(c=i,y):(c=i,v=u)}var a=!1,c,v,f=r===void 0?null:r;return[function(){return S(t())},f===null?void 0:function(){return S(f())}]},[t,r,n,s]);var l=Y(e,o[0],o[1]);return A(function(){d.hasValue=!0,d.value=l},[l]),ee(l),l};F.exports=H;var te=F.exports;const re=z(te),R=e=>{let t;const r=new Set,n=(c,v)=>{const f=typeof c=="function"?c(t):c;if(!Object.is(f,t)){const i=t;t=v??(typeof f!="object"||f===null)?f:Object.assign({},t,f),r.forEach(y=>y(t,i))}},s=()=>t,S={setState:n,getState:s,getInitialState:()=>a,subscribe:c=>(r.add(c),()=>r.delete(c)),destroy:()=>{r.clear()}},a=t=e(n,s,S);return S},ne=e=>e?R(e):R,{useDebugValue:se}=w,{useSyncExternalStoreWithSelector:oe}=re,ue=e=>e;function ae(e,t=ue,r){const n=oe(e.subscribe,e.getState,e.getServerState||e.getInitialState,t,r);return se(n),n}const D=(e,t)=>{const r=ne(e),n=(s,o=t)=>ae(r,s,o);return Object.assign(n,r),n},Se=(e,t)=>e?D(e,t):D;function me(e,t){if(Object.is(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;if(e instanceof Map&&t instanceof Map){if(e.size!==t.size)return!1;for(const[n,s]of e)if(!Object.is(s,t.get(n)))return!1;return!0}if(e instanceof Set&&t instanceof Set){if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0}const r=Object.keys(e);if(r.length!==Object.keys(t).length)return!1;for(const n of r)if(!Object.prototype.hasOwnProperty.call(t,n)||!Object.is(e[n],t[n]))return!1;return!0}const x=e=>{let t;const r=new Set,n=(a,c)=>{const v=typeof a=="function"?a(t):a;if(!Object.is(v,t)){const f=t;t=c??(typeof v!="object"||v===null)?v:Object.assign({},t,v),r.forEach(i=>i(t,f))}},s=()=>t,l={setState:n,getState:s,getInitialState:()=>S,subscribe:a=>(r.add(a),()=>r.delete(a))},S=t=e(n,s,l);return l},ie=e=>e?x(e):x,ce=e=>e;function le(e,t=ce){const r=w.useSyncExternalStore(e.subscribe,()=>t(e.getState()),()=>t(e.getInitialState()));return w.useDebugValue(r),r}const _=e=>{const t=ie(e),r=n=>le(t,n);return Object.assign(r,t),r},ye=e=>e?_(e):_;function fe(e,t){let r;try{r=e()}catch{return}return{getItem:s=>{var o;const d=S=>S===null?null:JSON.parse(S,t==null?void 0:t.reviver),l=(o=r.getItem(s))!=null?o:null;return l instanceof Promise?l.then(d):d(l)},setItem:(s,o)=>r.setItem(s,JSON.stringify(o,t==null?void 0:t.replacer)),removeItem:s=>r.removeItem(s)}}const $=e=>t=>{try{const r=e(t);return r instanceof Promise?r:{then(n){return $(n)(r)},catch(n){return this}}}catch(r){return{then(n){return this},catch(n){return $(n)(r)}}}},de=(e,t)=>(r,n,s)=>{let o={storage:fe(()=>localStorage),partialize:u=>u,version:0,merge:(u,g)=>({...g,...u}),...t},d=!1;const l=new Set,S=new Set;let a=o.storage;if(!a)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),r(...u)},n,s);const c=()=>{const u=o.partialize({...n()});return a.setItem(o.name,{state:u,version:o.version})},v=s.setState;s.setState=(u,g)=>{v(u,g),c()};const f=e((...u)=>{r(...u),c()},n,s);s.getInitialState=()=>f;let i;const y=()=>{var u,g;if(!a)return;d=!1,l.forEach(m=>{var h;return m((h=n())!=null?h:f)});const E=((g=o.onRehydrateStorage)==null?void 0:g.call(o,(u=n())!=null?u:f))||void 0;return $(a.getItem.bind(a))(o.name).then(m=>{if(m)if(typeof m.version=="number"&&m.version!==o.version){if(o.migrate){const h=o.migrate(m.state,m.version);return h instanceof Promise?h.then(I=>[!0,I]):[!0,h]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,m.state];return[!1,void 0]}).then(m=>{var h;const[I,W]=m;if(i=o.merge(W,(h=n())!=null?h:f),r(i,!0),I)return c()}).then(()=>{E==null||E(i,void 0),i=n(),d=!0,S.forEach(m=>m(i))}).catch(m=>{E==null||E(void 0,m)})};return s.persist={setOptions:u=>{o={...o,...u},u.storage&&(a=u.storage)},clearStorage:()=>{a==null||a.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>y(),hasHydrated:()=>d,onHydrate:u=>(l.add(u),()=>{l.delete(u)}),onFinishHydration:u=>(S.add(u),()=>{S.delete(u)})},o.skipHydration||y(),i||f},he=de;export{ye as a,Se as c,he as p,me as s,ae as u};
